#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, set = 0, binding = 0) uniform image2D image;

layout(push_constant) uniform constants {
    vec4 data1;
    vec4 data2;
    vec4 data3;
    vec4 data4;
    mat4 viewMatrix;
} PushConstants;

const double MAX_ITER = 256.0;
const double SPEED = 10.0;

vec3 hash(float m) {
    float x = fract(sin(m) * 5625.246);
    float y = fract(sin(m + x) * 2216.486);
    float z = fract(sin(x + y) * 8276.352);
    return vec3(x, y, z);
}

double mandelbrot(dvec2 uv) {
    dvec2 c = 2.0 * uv - dvec2(0.7, 0.0);
    dvec2 z = dvec2(0.0);
    double iter = 0.0;
    for (int i = 0; i < MAX_ITER; i++) {
        z = dvec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;

        if (dot(z, z) > 4.0)
            return iter / MAX_ITER;

        iter++;
    }

    return 0.0;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);

    if (texelCoord.x < size.x && texelCoord.y < size.y) {
        dvec2 aspectRatio = dvec2(size) / dvec2(max(size.x, size.y));
        dvec2 normalizedCoord = ((dvec2(texelCoord) / dvec2(size)) * 2.0 - 1.0) * aspectRatio;

        double zoom = exp(-0.1 * float(PushConstants.data2.x + PushConstants.data3.x * SPEED)); // data2.x is user defined, data3.x is time variable

        // Adjust coordinates for zoom and pan
        dvec2 center = PushConstants.data1.xy; // Center of the zoomed region
        normalizedCoord = (normalizedCoord - center) * zoom + center;

        dvec3 color = dvec3(0.0);
        double mandel = mandelbrot(normalizedCoord);
        color += hash(float(mandel));
        // color += mandel;
        color = pow(vec3(color), vec3(0.45)); // Gamma correction

        imageStore(image, texelCoord, vec4(color, 1.0));
    }
}
